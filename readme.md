### 1. Типы данных в .NET. CTS.

 Система общих типов CTS определяет способ объявления, использования и управления типами в среде CLR, а также является важной составной частью поддержки межъязыковой интеграции в среде выполнения. Система общих типов выполняет следующие функции.

1. Формирует инфраструктуру, которая позволяет обеспечивать межъязыковую интеграцию, безопасность типов и высокопроизводительное выполнение кода.
2. Предоставляет объектно-ориентированную модель, поддерживающую полную реализацию многих языков программирования.
3. Определяет правила, которых необходимо придерживаться в языке. Эти правила помогают обеспечить взаимодействие объектов, написанных на разных языках.
4. Предоставляет библиотеку, которая содержит типы-примитивы (например, Boolean, Byte, Char, Int32 и UInt64), используемые в разработке приложений.



Система общих типов CTS в платформе .NET Framework поддерживает следующие пять категорий типов:

1. Классы
2. Структуры
3. Перечисления
4. Интерфейсы
5. Делегаты

### 2. Предопределенные типы C#. Типы по значению и по ссылке. Упаковка и распаковка.
#### Предопределенные типы C#
[Про встроенные типы](https://msdn.microsoft.com/ru-ru/library/ya5y69ds(v=vs.90).aspx)
#### Типы по значению и по ссылке.
Все типы в платформе .NET Framework делятся на типы значений и ссылочные типы.

Значимые типы — это типы данных, объекты которых представлены фактическим значением объекта. Если экземпляр типа значения присваивается переменной, то эта переменная получает новую копию значения.

Ссылочные типы — это типы данных, объекты которых представлены ссылкой (аналогичной указателю) на фактическое значение объекта. Если экземпляр ссылочного типа присваивается переменной, то эта переменная будет ссылаться (указывать) на исходное значение. Копирования при этом не происходит.

#### Упаковка и распаковка.
Упаковка - процесс преобразования базового типа в тип `object`. В примере i упакован в объект o
```csharp
int i = 123;
object o = i;  
```
Распаковка - обратный процесс, преобразования типа `object` в базовый тип.

```csharp
o = 345;
i = (int)o;
```

Более жизненный пример.

```csharp
// Создаем список объектов
List<object> mixedList = new List<object>();

// Первым элементом добавляем строку
mixedList.Add("First Group:");

// Добавляем в список числа
for (int j = 1; j < 5; j++)
{
    // j запаковывается в объект
    mixedList.Add(j);
}

// Добавляем еще строку
mixedList.Add("Second Group:");
for (int j = 5; j < 10; j++)
{
    mixedList.Add(j);
}

// Выводим содержимое списка
foreach (var item in mixedList)
{
    Console.WriteLine(item);
}
```

### 3. Переменные. Модификаторы доступа. Статические пременные и переменные экземпляра.

#### Переменные
Переменная представляет числовое или строковое значение или объект класса. Значение, хранящееся в переменной, может измениться, однако имя остается прежним. Переменная представляет собой один тип поля. Следующий код является простым примером объявления целочисленной переменной, присвоения ей значения и последующего присвоения нового значения.
```csharp
int x = 1;  // x равно 1
x = 2;      // а теперь 2
```
Константа является другим типом поля. Она хранит значение, присваиваемое по завершении компиляции программы, и никогда после этого не изменяется. Константы объявляются помощью ключевого слова const; их использование способствует повышению удобочитаемости кода.
```csharp
const int speedLimit = 55;
const double pi = 3.14159265358979323846264338327950; // нельзя изменить во время иполнения программы
```
#### Модификаторы доступа

 - public: публичный, общедоступный класс или член класса. Такой член класса доступен из любого места в коде, а также из других программ и сборок.
- private: закрытый класс или член класса. Представляет полную противоположность модификатору public. Такой закрытый класс или член класса доступен только из кода в том же классе или контексте.
- protected: такой член класса доступен из любого места в текущем классе или в производных классах.
- internal: класс и члены класса с подобным модификатором доступны из любого места кода в той же сборке, однако он недоступен для других программ и сборок (как в случае с модификатором public).
- protected internal: совмещает функционал двух модификаторов. Классы и члены класса с таким модификатором доступны из текущей сборки и из производных классов.

#### Static
Иногда требуется определить такой член класса, который будет использоваться независимо от всех остальных объектов этого класса. Как правило, доступ к члену класса организуется посредством объекта этого класса, но в то же время можно создать член класса для самостоятельного применения без ссылки на конкретный экземпляр объекта. Для того чтобы создать такой член класса, достаточно указать в самом начале его объявления ключевое слово static.

В методе типа static должна отсутствовать ссылка this, поскольку такой метод не выполняется относительно какого-либо объекта

В методе типа static допускается непосредственный вызов только других методов типа static, но не метода экземпляра из того самого же класса. Дело в том, что методы экземпляра оперируют конкретными объектами, а метод типа static не вызывается для объекта. Следовательно, у такого метода отсутствуют объекты, которыми он мог бы оперировать

Аналогичные ограничения накладываются на данные типа static. Для метода типа static непосредственно доступными оказываются только другие данные типа static, определенные в его классе. Он, в частности, не может оперировать переменной экземпляра своего класса, поскольку у него отсутствуют объекты, которыми он мог бы оперировать


### 4. Операции
1. `+` операция сложения двух чисел: `z=x+y`
2. `-` операция вычитания двух чисел: `z=x-y`
3. `*` операция умножения двух чисел: `z=x*y`
4. `/` операция деления двух чисел: `z=x/y`
5. `%` получение остатка от деления двух чисел: `z=x%y`
6. `++` (префиксный инкремент) `z=++y` (сначала значение переменной y увеличивается на 1, а потом ее значение присваивается переменной z)
7. `++` (постфиксный инкремент) `z=y++` (сначала значение переменной y присваивается переменной z, а затем значение переменной y увеличивается на 1)
8. `--` (префиксный декремент) `z=--y` (сначала значение переменной y уменьшается на 1, а потом ее значение присваивается переменной z)
9. `--` (постфиксный декремент) `z=y--` (сначала значение переменной y присваивается переменной z, а затем значение переменной y уменьшается на 1)
10. `&` (логическое умножение)
11. `|` (логическое сложение)
12. `^` (логическое исключающее ИЛИ)
13. `~` (логическое отрицание)
14. `x<<y` - сдвигает число x влево на y разрядов. Например, `4<<1` сдвигает число 4 (которое в двоичном представлении 100) на один разряд влево, то есть в итоге получается 1000 или число 8 в десятичном представлении.
15. `x>>y` - сдвигает число x вправо на y разрядов. Например, `16>>1` сдвигает число 16 (которое в двоичном представлении 10000) на один разряд вправо, то есть в итоге получается 1000 или число 8 в десятичном представлении.
16. `==` сравнивает два операнда на равенство: `z=x==y`; z равно true, если x равно y, иначе z будет равно false
17. `!=` `z=x!=y;` (z равно true, если x не равно y, иначе z будет равно false)
18. `<` `z=x<y;` (z равно true, если x меньше y, иначе z будет равно false)
19. `>` `z=x>y;` (z равно true, если x больше y, иначе z будет равно false)
20. `<=` `z=x<=y;` (z равно true, если x меньше или равно y, иначе z будет равно false)
21. `>=` `z=x>=y`; (z равно true, если x больше или равно y, иначе z будет равно false)
22. `=` самая распространенная операция, просто приравнивает одно значение другому: z=x;
23. `+=` `z+=y`; (переменной z присваивается результат сложения z и y)
24. `-=` `z-=y`; (переменной z присваивается результат вычитания y из z)
25. `*=` `z*=y`; (переменной z присваивается результат произведения z и y)
26. `/=` `z/=y`; (переменной z присваивается результат деления z на y)
27. `%=` `z%=y`; (переменной z присваивается остаток от деления z на y)
28. `&=` `z&=y`; (переменной z присваивается значение `z&y`)
29. `|=` `z|=y`; (переменной z присваивается значение `z|y`)
30. `^=` `z^=y`; (переменной z присваивается значение `z^y`)
31. `<<=` `z<<=y`; (переменной z присваивается значение `z<<y`)
32. `>>=` `z>>=y`; (переменной z присваивается значение `z>>y`)
